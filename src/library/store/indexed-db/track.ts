/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import { compact, flatMap, omit } from 'lodash';
import type { LibraryDatabase } from './db';
import type { Track, Identifier } from 'app/src-core/library';
import type { ListOptions, TrackStore } from 'app/src-core/library/store/track';

export class IndexedDbTrackStore implements TrackStore {
  constructor(protected db: LibraryDatabase) {}

  async add(tracks: Track[]): Promise<void> {
    const insertedTracks = await this.addTracks(tracks);
    await this.addIdentifiersFrom(insertedTracks);
  }

  async findByIdentifiers(identifiers: Identifier[]): Promise<Track[]> {
    const trackIdentifiers = await this.db.identifiers
      .where('[name+value]')
      .anyOf(identifiers.map((id) => [id.name, id.value]))
      .toArray();
    const trackIds = compact(trackIdentifiers).map((id) => id?.trackId);
    const tracks = await this.db.tracks.bulkGet(trackIds);
    return compact(tracks);
  }

  async list(options: ListOptions): Promise<Track[]> {
    return this.db.tracks.offset(options.offset).limit(options.limit).toArray();
  }

  private async addTracks(tracks: Track[]): Promise<Track[]> {
    // ignore any provided ids so that it can be auto generated by IndexedDb
    const tracksToInsert = tracks.map((track) => omit(track, 'id'));
    const trackIds = await this.db.bulkAddTracks(tracksToInsert);
    return tracks.map((track, i) => {
      const id = trackIds[i];

      if (!id) {
        throw new Error('Mismatch in track IDs length');
      }

      return { ...track, id };
    });
  }

  private async addIdentifiersFrom(tracks: Track[]): Promise<void> {
    const identifiersToInsert = flatMap(tracks, (track) =>
      track.identifiers.map((identifier) => ({
        trackId: track.id,
        ...identifier,
      })),
    );

    await this.db.bulkAddIdentifiers(identifiersToInsert);
  }
}
