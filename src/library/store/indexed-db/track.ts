/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

import { compact, flatMap, omit } from 'lodash';
import type { ITrack, LibraryDatabase } from './db';
import type { Track, Identifier } from 'app/src-core/library';
import type { ListOptions, TrackStore } from 'app/src-core/library/store/track';

export class IndexedDbTrackStore implements TrackStore {
  constructor(protected db: LibraryDatabase) {}

  async add(tracks: Track[]): Promise<void> {
    const insertedTracks = await this.addTracks(tracks);
    await this.addIdentifiersFrom(insertedTracks);
  }

  async update(tracks: Track[]): Promise<void> {
    const tracksWithArtwork = await this.db.artwork
      .where('trackId')
      .anyOf(tracks.map((t) => t.id))
      .primaryKeys();

    await this.db.tracks.bulkUpdate(
      tracks.map((track) => ({
        key: track.id,
        changes: { ...toDbTrack(track, tracksWithArtwork.includes(track.id)) },
      })),
    );
  }

  async findByIdentifiers(identifiers: Identifier[]): Promise<Track[]> {
    const trackIdentifiers = await this.db.identifiers
      .where('[name+value]')
      .anyOf(identifiers.map((id) => [id.name, id.value]))
      .toArray();
    const trackIds = compact(trackIdentifiers).map((id) => id?.trackId);
    const tracks = await this.db.tracks.bulkGet(trackIds);
    return compact(tracks).map(toTrack);
  }

  async findTracksWithoutMetadata(options: ListOptions): Promise<Track[]> {
    const tracks = await this.db.tracks
      .where('hasMetadata')
      .equals(0)
      .limit(options.limit)
      .offset(options.offset)
      .toArray();
    return tracks.map(toTrack);
  }

  async list(options: ListOptions): Promise<Track[]> {
    const tracks = await this.db.tracks.offset(options.offset).limit(options.limit).toArray();
    return tracks.map(toTrack);
  }

  async getArtwork(track: Track): Promise<Uint8Array | null> {
    const art = await this.db.artwork.get({ trackId: track.id });
    return art?.artwork || null;
  }

  async storeArtwork(track: Track, art: Uint8Array | undefined): Promise<void> {
    await this.db.artwork.put({ trackId: track.id, artwork: art });
    await this.db.tracks.where({ id: track.id }).modify((track) => {
      track.hasMetadata = track.metadata ? 1 : 0;
    });
  }

  private async addTracks(tracks: Track[]): Promise<Track[]> {
    // ignore any provided ids so that it can be auto generated by IndexedDb
    const tracksToInsert = tracks.map((track) => omit(toDbTrack(track), 'id'));
    const trackIds = await this.db.bulkAddTracks(tracksToInsert);
    return tracks.map((track, i) => {
      const id = trackIds[i];

      if (!id) {
        throw new Error('Mismatch in track IDs length');
      }

      return { ...track, id };
    });
  }

  private async addIdentifiersFrom(tracks: Track[]): Promise<void> {
    const identifiersToInsert = flatMap(tracks, (track) =>
      track.identifiers.map((identifier) => ({
        trackId: track.id,
        ...identifier,
      })),
    );

    await this.db.bulkAddIdentifiers(identifiersToInsert);
  }
}

function toTrack(dbTrack: ITrack): Track {
  const track: Track = {
    id: dbTrack.id,
    file: dbTrack.file,
    identifiers: dbTrack.identifiers,
    mime: dbTrack.mime,
    source: dbTrack.source,
  };

  if (dbTrack.metadata) {
    track.metadata = dbTrack.metadata;
  }

  return track;
}

function toDbTrack(track: Track, hasArtwork = true): ITrack {
  return {
    ...track,
    hasMetadata: track.metadata && hasArtwork ? 1 : 0,
  };
}
